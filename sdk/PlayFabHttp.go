package playfab

// This code was generated by a tool. Any changes may be overwritten

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
	"strings"
	"time"
)

type playFabResponse struct {
	StatusCode        int                    `json:"code"`         // Numerical HTTP code
	RemoteStatus      string                 `json:"status"`       // String HTTP code
	RemoteErrMsg      string                 `json:"errorMessage"` // Description for the PlayFab errorCode
	RemoteErrCode     int                    `json:"errorCode"`    // Numerical PlayFab error code
	RemoteErrCodeText string                 `json:"error"`        // Text Playfab error code
	RemoteErrDetails  map[string][]string    `json:"errorDetails"`
	Data              map[string]interface{} `json:"data"`
}

// CustomError contains data about an local error during HTTP operation
type CustomError struct {
	ErrCode ErrorCode // local ErrorCode for the error
	ErrMsg  string    // local text error message
}

// CustomRemoteError contains data about an remote error from the HTTP operation
type CustomRemoteError struct {
	ErrCode           ErrorCode // local ErrorCode for the error
	RemoteStatus      string    // String HTTP code
	RemoteErrCode     int       // Numerical PlayFab error code
	RemoteErrCodeText string    // Text Playfab error code
	RemoteErrMsg      string    // Description for the PlayFab errorCode
	RemoteErrDetails  map[string][]string
}

func (p *CustomError) Error() string {
	return fmt.Sprintf("Code: %v Message: %v", p.ErrCode, p.ErrMsg)
}

func (p *CustomRemoteError) Error() string {
	return fmt.Sprintf("ErrCode:%v RemoteStatus:%v RemoteErrCode:%v RemoteErrorMsg:%v RemoteErrCodeText:%v RemoteErrDetails: %v",
		p.ErrCode, p.RemoteStatus, p.RemoteErrCode, p.RemoteErrMsg, p.RemoteErrCodeText, p.RemoteErrDetails)
}

// NewCustomRemoteError returns a new CustomError with a message and an error code
func NewCustomRemoteError(res *playFabResponse, errCode ErrorCode) *CustomRemoteError {
	return &CustomRemoteError{ErrCode: errCode, RemoteErrMsg: res.RemoteErrMsg, RemoteErrCode: res.RemoteErrCode,
		RemoteErrCodeText: res.RemoteErrCodeText, RemoteErrDetails: res.RemoteErrDetails}
}

// NewCustomError returns a new CustomError with a message and an error code
func NewCustomError(msg string, errCode ErrorCode) *CustomError {
	return &CustomError{ErrCode: errCode, ErrMsg: msg}
}

// ErrorCode is a custom error code
type ErrorCode int

const (
	// ErrorUnmarshal is an error during response unmarshaling
	ErrorUnmarshal ErrorCode = iota
	// ErrorGZIP is an error during GZIPing
	ErrorGZIP
	// ErrorCreateRequest is an error during request creation
	ErrorCreateRequest
	// ErrorDoRequest is an error during request execution
	ErrorDoRequest
	// ErrorMarshal is an error during POST data marshaling
	ErrorMarshal
	// ErrorDecoding is an error that occurs during map[string]interface{} -> struct creation
	ErrorDecoding
	// ErrorGeneric represents a generic error
	ErrorGeneric
	// ErrorRemote represents remote error
	ErrorRemote
)

// AdType
type AdType string

const (
	AdTypeIdfa                AdType = "Idfa"
	AdTypeAndroidId           AdType = "Adid"
	AdTypeIdfaSuccessful      AdType = "Idfa_Successful"
	AdTypeAndroidIdSuccessful AdType = "Adid_Successful"
)

// Settings includes various conf options for PlayFab HTTP call
type Settings struct {
	VersionString            string
	RequestGetParams         map[string]string
	ProductionEnvironmentURL string
	EnableCompression        bool
	VerticalName             string
	TitleId                  string
	DisableSsl               bool
	APIPath                  string
	AdvertisingIdType        AdType
	AdvertisingIdValue       string
	DisableAdvertising       bool
}

// NewSettingsWithDefaultOptions  returns a pointer to a Settings struct that carries default values
// Requires a valid titleId
func NewSettingsWithDefaultOptions(titleId string) *Settings {
	return &Settings{
		VersionString:            "GoSdk-",
		RequestGetParams:         map[string]string{"sdk": ""},
		ProductionEnvironmentURL: ".playfabapi.com", // This is only for customers running a private cluster.  Generally you shouldn't touch this
		EnableCompression:        false,
		VerticalName:             "", // The name of a customer vertical. This is only for customers running a private cluster. Generally you shouldn't touch this
		TitleId:                  titleId,
		DisableSsl:               false,
		DisableAdvertising:       false,
	}
}

// getFullURL returns the full URL to be used for the API call
func (p *Settings) getFullURL(apiPath string) string {
	var output string

	if !strings.HasPrefix(p.ProductionEnvironmentURL, "http") {
		if p.VerticalName != "" {
			output = "https://" + p.VerticalName
		} else {
			output = "https://" + p.TitleId
		}
	}

	output += p.ProductionEnvironmentURL
	output += apiPath

	firstParam := true
	for key, val := range p.RequestGetParams {
		if firstParam {
			output += "?"
			firstParam = false
		} else {
			output += "&"
		}
		output += fmt.Sprintf("%s=%s", key, val)
	}

	return output
}

// Request executes the actual HTTP call
func Request(p *Settings, b []byte, apiPath string, authKey string, authValue string) (map[string]interface{}, error) {
	client := &http.Client{
		Timeout: time.Second * 30, // 30 seconds timeout should be enough
	}

	if p.DisableSsl {
		client.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	var req *http.Request
	var err error

	// compression enabled, so gzip POST data
	if p.EnableCompression {
		var buf bytes.Buffer
		zw := gzip.NewWriter(&buf)
		if _, err := zw.Write(b); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		if err := zw.Flush(); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		if err := zw.Close(); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		req, err = http.NewRequest("POST", p.getFullURL(apiPath), &buf)
		if err != nil {
			return nil, NewCustomError(err.Error(), ErrorCreateRequest)
		}
		req.Header.Add("Content-Encoding", "GZIP")
	} else {
		req, err = http.NewRequest("POST", p.getFullURL(apiPath), bytes.NewBuffer(b))
		if err != nil {
			return nil, NewCustomError(err.Error(), ErrorCreateRequest)
		}
	}

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("X-ReportErrorAsSuccess", "true")
	req.Header.Add("X-PlayFabSDK", p.VersionString)

	if authKey != "" && authValue != "" {
		req.Header.Add(authKey, authValue)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorDoRequest)
	}
	defer resp.Body.Close()

	bodyBytes, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorDoRequest)
	}

	result := playFabResponse{}
	err = json.Unmarshal(bodyBytes, &result)
	//fmt.Println(result)
	//fmt.Println(bytes.NewBuffer(bodyBytes).String())
	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorUnmarshal)
	}

	if result.StatusCode != 200 {
		return nil, NewCustomRemoteError(&result, ErrorRemote)
	}

	return result.Data, nil
}

// StringToDateTimeHook is used with mapstructure package to correctly unmarshal time fields
// https://github.com/mitchellh/mapstructure/issues/41
func StringToDateTimeHook(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
	if t == reflect.TypeOf(time.Time{}) && f == reflect.TypeOf("") {
		return time.Parse(time.RFC3339, data.(string))
	}
	return data, nil
}
